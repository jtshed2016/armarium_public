{% extends "base.html" %}
{% block content %}

<h3>Robbins MS {{ ms.id }} - {{ ms.titles.filter_by(title_type='main').first().title_text }}</h3>
<div class="section">


{% if ms.titles.filter(title_type in['uniform', 'varying', 'secundo']) %}
	<!--<h4>Variations of Title:</h4>-->
	{% if ms.titles.filter_by(title_type='uniform').first() %}
	<p><b>Uniform Title:</b> {{ ms.titles.filter_by(title_type='uniform').first().title_text }}</p>
	<br>
	{% endif %}
	
	{% if ms.titles.filter_by(title_type='secundo').first() %}
	<p><b>Secundo folio:</b> {{ ms.titles.filter_by(title_type='secundo').first().title_text }}</p>
	<br>
	{% endif %}
	

	{% if ms.titles.filter_by(title_type='varying').count() >0 %}
	<p><b>Variations of Title:</b></</p>
		<ul>
		{% for alt_title in ms.titles.filter_by(title_type='varying') %}
		<li>{{ alt_title.title_text }}</li>

		{% endfor %}
		</ul>
	{% endif %}
{% endif %}

{% if ms.datetype == 's' %}
	{% if ms.datecertain == True %}
  <br>
	<p><b>Date:</b> {{ ms.date1 }}</p>
	{% else %}
  <br>
	<p><b>Date:</b> ca. {{ ms.date1 }}</p>

	{% endif %}

{% elif ms.datetype in ['k','q','i'] %}
<br>
<p><b>Dates:</b> between {{ms.date1}} and {{ms.date2}}</p>

{% else %}
<br>
<p><b>Dates:</b> {{ms.date1}}-{{ms.date2}}</p>

{% endif %}
<br>
<p><b>Language: </b><a href="{{url_for('ms_by_language', focus_lang_id=ms.ms_language.id)}}">{{ ms.ms_language.name }}</a></p>

{% if ms.publisher %}
<p>Published by: {{ ms.publisher }}</p>
{% endif %}

{% if ms.places|length() > 1 %}
<br>
<p><b>Places of Origin:</b><p>
{% else %}
<br>
<p><b>Place of Origin:</b><p>
{% endif %}
<ul>
{% for place in ms.places %}
<li><a href="{{ 'place' + (place.id|string) }}">{{ place.place_name }}</a></li>
{% endfor %}
</ul>

{% if people|length > 0 %}
<br>
<p><b>Associated People:</b></p>
<ul>
{% for person_rel in people %}
<li><a href="{{ 'person' +(person_rel|string) }}">{{ people[person_rel]['name'] }}</a> â€“ {{ people[person_rel]['roles'] }}</li>
{% endfor %}
</ul>
{% endif %}

{% if ms.orgs.count() >0 %}
<br>
<p><b>Associated Organizations:</b></p>
<ul>
{% for relorg in ms.orgs %}
<li><a href="org{{relorg.org.id}}">{{ relorg.org.name }}</a></li>
{% endfor %}
</ul>
{% endif %}


{% if ms.watermarks|length() > 0 %}
<br>
<p><b>Watermarks:</b><p>
{% for wm in ms.watermarks %}
<a href="{{ 'watermark' + (wm.id|string) }}">Briquet {{ wm.id }} "{{ wm.name }}"</a>
{% endfor %}
{% endif %}
<br>
{% if ms.summary %}
<br>
<p><b>Summary</b></p>
<p>{{ ms.summary }}</p>
{% endif %}

{% if ms.origin %}
<br>
<p><b>Origin</b></p>
<p>{{ ms.origin }}</p>
{% endif %}

{% if ms.ownership_history %}
<br>
<p><b>Ownership History</b></p>
<p>{{ ms.ownership_history }}</p>
{% endif %}
<br>






{% if ms.ms_format %}
<p><b>Format: </b><a href="{{url_for('ms_by_format', focusformat=ms.ms_format)}}">{{ ms.ms_format }}</a></p>
{% endif %}

<p><b>Number of Volumes:</b> {{ ms.num_volumes }}</p>

{% for volume in ms.volumes %}
{% if ms.volumes.all()|length() >1 %}
<h4>Volume {{ volume.numeration }}</h4>
{% endif %}
{% if volume.support %}
<p><b>Material: </b><a href="{{url_for('ms_by_support', focussupport=volume.support)}}">{{ volume.support }}</a></p>
{% endif %}

{% if volume.extent %}
<p><b>Extent:</b> {{ volume.extent }} {{volume.extent_unit }}</p>
{% endif %}

{%if volume.leaf_height or volume.written_height or volume.bound_height %}
<p><b>Dimensions:</b></p>
<ul>
{% if volume.leaf_height and volume.leaf_width %}
<li>Support dimensions: {{volume.leaf_height}} x {{ volume.leaf_width }} {{volume.size_unit}}</li>
{% endif %}

{% if volume.written_height and volume.written_width %}
<li>Written area: {{volume.written_height}} x {{volume.written_width}} {{volume.size_unit}}</li>
{% endif %}

{% if volume.bound_height and volume.bound_width %}
<li>Bound to {{volume.bound_height}} x {{volume.bound_width}} {{volume.size_unit}}</li>
{% endif %}
</ul>
{% endif %}

{% if volume.scripts|length ==1 %}
<p><b>Script: </b><a href="{{url_for('ms_by_script', idno=volume.scripts[0].id)}}">{{volume.scripts[0].name}}</a></p>
{% elif volume.scripts|length >1 %}
<p><b>Scripts:</b></p>
<ul>
{% for script in volume.scripts %}
<li><a href="{{url_for('ms_by_script', idno= script.id)}}">{{ script.name }}</a></li>
{% endfor %}
</ul>
{% endif %}

{% if volume.ruling|length ==1 %}
<p><b>Ruling: </b> <a href="{{url_for('ms_by_ruling', idno=volume.ruling[0].id)}}">{{ volume.ruling[0].name }}</a></p>
{% elif volume.ruling|length >1 %}
<p><b>Ruling:</b></p>
<ul>
{% for rule in volume.ruling %}
<li><a href="{{url_for('ms_by_ruling', idno=rule.id)}}">{{ rule.name }}</a></li>
{% endfor %}
</ul>
{% endif %}

{% if volume.quire_register %}
<p><b>Register of Quires:</b> {{ volume.quire_register }}</p>
{% endif %}

{% if volume.phys_arrangement %}
<p><b>Arrangement:</b> {{ volume.phys_arrangement }}</p>
<br>
{% endif %}

{% endfor %}

{% if ms.binding %}
<p><b>Binding:</b> {{ ms.binding }}</p>
<br>
{% endif %}

{% if ms.decoration %}
<p><b>Decoration:</b> {{ ms.decoration }}</p>
<br>
{% endif %}

{% if ms.ds_url %}
<p><a href="{{ms.ds_url}}">View images</a> at Digital Scriptorium</p>
{% endif %}
</div>


{% if ms.contents.first() %}
{% for volume in ms.volumes %}
{% if ms.volumes.all()|length == 1 %}
<h4>Contents</h4>
{% elif ms.volumes.all()|length > 1%}
<h4>Contents of Volume {{ volume.numeration }}</h4>
{% endif %}
<table class="contentstable">
{% for textitem in volume.contents %}
<tr>
	<td>{{ textitem.fol_start_num }}{{ textitem.fol_start_side }} 
	{% if textitem.fol_end_num != None %}
	- {{ textitem.fol_end_num }}
	{% endif %}
	{% if textitem.fol_end_side != None %}
	{{ textitem.fol_end_side }}
	{% endif %}
	</td>
	<td>{{ textitem.text }}</td>
</tr>

{% endfor %}
</table>
{% endfor %}
{% endif %}
<!--canvases for d3 visualizations-->
<div class="section" id="relationvis">
</div>
<script src="static/d3.v4.min.js"></script>
<script>
//tablelookup and jsonEndPoint for getNewNodes function
//tablelookup has ints that correspond to DB entities; together with dbkey, these can uniquely ID a node
var tablelookup = {0: 'manuscript', 1: 'person', 2: 'place', 3: 'watermark', 4: 'org',
5: 'exdoc', 6: 'subject', 7: 'publisher'};

var endpointPath = '/sendjson'

var width = 900,
    height = 450;

//variables for forces in graph:
//forceStrength -- level of attraction (or repulsion, if negative)
var forceStrength = -80
//maximum distance between two nodes
var maximumDistance = 150
//minimum distance between two nodes
var minimumDistance = 40

var svg = d3.select("#relationvis").append("svg")
    .attr("id", "graphcanvas")
    .attr("width", width)
    .attr("height", height);

var graph = {{ graphsend|safe }}


var color = d3.scaleOrdinal(d3.schemeCategory20);


var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody().strength(forceStrength).distanceMax(maximumDistance).distanceMin(minimumDistance))
    .force("center", d3.forceCenter(width / 2, height / 2));


  var link = svg.append("g")
    .attr("class", "links")
  .selectAll("line")
    .data(graph.links, function(d) { return d.source.id + '-' + d.target.id})
    .enter().append("line")
    .style("stroke-width", function(d) { return Math.sqrt(d.value)});

  var node = svg.append("g")
    .attr("class", "nodes")
  .selectAll("circle")
    .data(graph.nodes, function(d) {return d.id})
    .enter()
    .append("circle")
    .attr("r", 5)
    .attr("fill", function(d) {return color(d.group); })
    .attr("id", function(d) {return d.id; })
    .attr("onclick", "getNewNodes(this)")
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

  var labels = svg.selectAll("text.labels")
    .data(graph.nodes)
    .enter().append("text")
    //.attr("text-anchor", "end")
    .attr("dx", -10)
    .attr("dy", ".35em")
    .attr("class", "labels")
    .attr("fill", "black")
    .text(function(d) { return d.name; });
  

  simulation
    .nodes(graph.nodes)
    .on("tick", ticked);
  
  simulation.force("link")
    .links(graph.links)

  function ticked() {
    link
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; })

    node
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });

    labels
      .attr("transform", function(d) { return "translate(" + (d.x + 5).toString() + "," + (d.y).toString() + ")";});
  }

 function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
 }

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}


function nodeExists(currNode) {
  //for use with array.find -- returns "true" if node already exists in graph array
  return currNode.id === this.id;
}

function linkExists(currLink) {
  //for use with array.find -- returns "true" if link or inverse already exists in graph array
  //console.log('current source: ', currLink.source);
  //console.log('current link ID (under iteration): ', currLink.source.id);

  return ((currLink.source.id === this.source) && (currLink.target.id === this.target)
    ||
    (currLink.source.id === this.target) && (currLink.target.id === this.source))
}


function getNewNodes(currNode) {
  idArgs = currNode.id.split('_')
  entity = tablelookup[idArgs[0]]
  dbID = idArgs[1]
//sends REQUEST to JSON endpoint to get new subgraph associated with node, calls update function
//destURL -- change to send entity name and ID when integrated
destURL = endpointPath + '?entity=' + entity + '&id=' + dbID + '&state=add'
d3.json(destURL, function (newGraph) {
  update(newGraph);
})
}

function update(newData) {
  //takes new data, checks to see if nodes/links already exist, adds if necessary, re-renders graph
  for (x in newData.nodes) {
    //check for existing nodes
    if (graph.nodes.find(nodeExists, newData.nodes[x]) === undefined) {
      graph.nodes.push(newData.nodes[x])
      //if a node isn't in the graph, "undefined" is returned and the new node is pushed to array
    }
    

  }
  for (y in newData.links) {
    //check for existing links
    if (graph.links.find(linkExists, newData.links[y]) === undefined) {
      //if a link isn't in the graph, "undefined" is returned and the new link is pushed to array
      newLinkSource = graph.nodes.find( function(oldNode) { return oldNode.id === this.source}, newData.links[y]);
      newLinkTarget = graph.nodes.find( function(oldNode) { return oldNode.id === this.target}, newData.links[y]);
      graph.links.push({'source': newLinkSource, 'target': newLinkTarget, 'value': 10})
    }
  }

  //update nodes, links, and labels with new data and merge
  node = node.data(graph.nodes, function(d) { return d.id;});
  node.exit().remove();
  node = node.enter()
  .append("circle")
  .attr("r", 5)
  .attr("fill", function(d) { return color(d.group)})
  .attr("id", function(d) {return d.id; })
  .attr("onclick", "getNewNodes(this)")
  .call(d3.drag()
  .on("start", dragstarted)
  .on("drag", dragged)
  .on("end", dragended))
  .merge(node);


  link = link.data(graph.links, function(d) { return d.source.id + "-" + d.target.id; });
  link.exit().remove();
  link = link.enter().append("line").merge(link).style("stroke-width", function(d) { return Math.sqrt(d.value)});

  labels = labels.data(graph.nodes);
  labels.exit().remove()
  labels = labels.enter()
  .append("text")
    .attr("dx", -10)
    .attr("dy", ".35em")
    .attr("class", "labels")
    .attr("fill", "black")
    .text(function(d) {return d.name})
    .merge(labels);

//restart simulation with new data
  simulation
    .nodes(graph.nodes)
  .force("link").links(graph.links);
  simulation
    .force("charge", d3.forceManyBody().strength(forceStrength).distanceMax(maximumDistance).distanceMin(minimumDistance))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .alpha(1).restart();
}

</script>


</div>
{% endblock %}